<html>
    <head>
        <title>Raspberry PI OS Dev - SudoCpp</title>
        <link rel="stylesheet" href="styles/sidebarStyle.css">
    </head>
    <body>
        <div id="banner">
            <a href="index.html" id="logo">$ SudoCpp</a>
        </div>
        <div id="projectsBar">
            <span>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            </span>
            <a href="cp3m.html" class="barLink">Cpp Project Manager</a> | 
            <a href="simplex.html" class="barLink">Simplex Toolkit</a> | 
            <a href="raspOS.html" class="barLink">Raspberry PI OS Dev</a>
        </div>
        <div id="sidebar">
            <a href="raspOS.html" class="sideLink">Introduction</a><br>
            <a href="raspParts.html" class="sideLink">Parts of a Tiny Kernel</a><br>
            <a href="raspBoot.html" class="sideLink">boots.S File</a><br>
        </div>
        <div id="page"></div>
        <div id="textPage">
            <div id="textFrame">
                <h2>Raspberry PI OS Dev</h2>
                <h3>Parts of a Tiny Kernel</h3>
                <p>
                    Upon reviewing all the forementioned tutorials, there needs to be an Assembly
                    file. This file either acts as a kernel itself, or is used to set up an
                    environment that C/C++ can operate.
                </p>
                <p>
                    In the Cambridge example they start by turned the OK/ACT light on. I like how 
                    simple this example is, but I don't want somehow burn something up. I will
                    follow the examples from the other tutorials which use QEMU.
                </p>
                <p>
                    I like to be able to get an output like a "Hello World" of some sort so that
                    I know my compiler is working, my emulator is working and that any issues I 
                    have are because of the code and not because of the environment. First let's 
                    get an emulator and a compiler.
                </p>
                <p>
                    sudo apt install qemu gcc-arm-none-eabi
                </p>
                <p>
                    The QEMU emulator has built in support for Raspberry PI. Since we are compiling
                    on a machine that doesn't have an ARM processor, the compiler will cross-compile 
                    so that the ARM processor can understand what is being sent to it.
                </p>
                <p>
                    I will create a new folder on my machine and open it with Visual Studio Code.
                    Then add a file called "boot.S". When the Raspberry PI is turned on. The bootloader 
                    will start to run and it will look for code at address 0x8000. The code in "boot.S"
                    is what we will be placing at 0x8000. The fun this for me is that I own a Raspberry PI
                    A. That's right a 1st generation. QEMU emulates the 2nd generation, which means that
                    moving from emulation to real life will require tweaking this file. (Just goes to show
                    how specific code is to your system.)
                </p>
                <p>
                    The boot.S file will then call the function kernal_main and we can proceed from there.
                </p>
                <p>
                    The next sections will go into details for these files.
                </p>
            </div>
        </div>
    </body>
</html>
